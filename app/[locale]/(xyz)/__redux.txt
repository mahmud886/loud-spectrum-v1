// ============================================================================

// Installation:

// npm install @reduxjs/toolkit react-redux redux-persist

// ============================================================================

// ============================================================================

// File: src/store/slices/productSlice.js

// Description: Redux slice for managing product state.

// ============================================================================

import { createSlice } from '@reduxjs/toolkit';

// Define the initial state for the product slice

const initialState = {

  items: [], // Array to hold product objects

  // You might add loading, error states here for data fetching, e.g.:

  // loading: false,

  // error: null,

};

// Create the product slice using createSlice

export const productSlice = createSlice({

  name: 'product', // The name of the slice (used in action types)

  initialState, // The initial state defined above

  reducers: {

    // Reducer to set the list of products

    setProducts: (state, action) => {

      // Immer allows direct mutation of state within reducers

      state.items = action.payload; // Update the items array with the payload

    },

    // Add other product-related reducers here if needed, for example:

    // addProduct: (state, action) => {

    //   state.items.push(action.payload);

    // },

    // removeProduct: (state, action) => {

    //   state.items = state.items.filter(item => item.id !== action.payload);

    // },

    // updateProduct: (state, action) => {

    //   const index = state.items.findIndex(item => item.id === action.payload.id);

    //   if (index !== -1) {

    //     state.items[index] = action.payload;

    //   }

    // },

  },

});

// Export the action creators generated by createSlice

export const { setProducts } = productSlice.actions;

// Export the reducer function for this slice

export default productSlice.reducer;

// ============================================================================

// File: src/store/slices/cartSlice.js

// Description: Redux slice for managing shopping cart state.

// ============================================================================


// Define the initial state for the cart slice

const initialState = {

  items: [], // Array to hold items in the cart

  totalItems: 0, // Total count of items (sum of quantities)

  totalPrice: 0, // Total price of items in the cart

};

// Create the cart slice using createSlice

export const cartSlice = createSlice({

  name: 'cart', // The name of the slice

  initialState, // The initial state

  reducers: {

    // Reducer to add an item to the cart or increase quantity if it exists

    addItem: (state, action) => {

      const existingItem = state.items.find(item => item.id === action.payload.id);

      if (existingItem) {

        // If item already exists, increase its quantity

        existingItem.quantity++;

      } else {

        // If item is new, add it to the items array with quantity 1

        state.items.push({ ...action.payload, quantity: 1 });

      }

      // Update total counts

      state.totalItems++;

      state.totalPrice += action.payload.price;

    },

    // Reducer to remove an item from the cart

    removeItem: (state, action) => {

      const itemIndex = state.items.findIndex(item => item.id === action.payload);

      if (itemIndex > -1) {

        const item = state.items[itemIndex];

        // Decrease total counts based on the removed item's quantity and price

        state.totalItems -= item.quantity;

        state.totalPrice -= item.price * item.quantity;

        // Remove the item from the array

        state.items.splice(itemIndex, 1);

      }

    },

    // Reducer to update the quantity of a specific item in the cart

    updateItemQuantity: (state, action) => {

      const item = state.items.find(item => item.id === action.payload.id);

      if (item && action.payload.quantity >= 0) {

        // Calculate the difference in quantity

        const quantityDiff = action.payload.quantity - item.quantity;

        // Update the item's quantity

        item.quantity = action.payload.quantity;

        // Update total counts based on the quantity difference

        state.totalItems += quantityDiff;

        state.totalPrice += quantityDiff * item.price;

         // Optional: remove item from the array if its quantity becomes 0

        if (item.quantity === 0) {

             state.items = state.items.filter(item => item.id !== action.payload.id);

        }

      }

    },

    // Reducer to clear all items from the cart

    clearCart: (state) => {

      state.items = [];

      state.totalItems = 0;

      state.totalPrice = 0;

    }

  },

});

// Export the action creators

export const { addItem, removeItem, updateItemQuantity, clearCart } = cartSlice.actions;

// Export the reducer

export default cartSlice.reducer;

// ============================================================================

// File: src/store/store.js

// Description: Redux store configuration with redux-persist.

// ============================================================================

import { combineReducers, configureStore } from '@reduxjs/toolkit';

import {
  FLUSH,
  PAUSE,

  PERSIST,
  persistReducer,
  persistStore,
  PURGE,

  REGISTER,
  REHYDRATE,
} from 'redux-persist';

// Import the storage engine (localStorage for web)

import storage from 'redux-persist/lib/storage'; // defaults to localStorage for web

// Import your slice reducers

import productReducer from './slices/productSlice';

import cartReducer from './slices/cartSlice';

// Combine all your individual reducers into a root reducer

const rootReducer = combineReducers({

  product: productReducer, // Add product slice reducer

  cart: cartReducer,     // Add cart slice reducer

  // Add other reducers here if needed

});

// Configuration object for redux-persist

const persistConfig = {

  key: 'nextjs-redux-js-store', // A unique key for identifying the persisted state in storage

  storage, // The storage mechanism to use (e.g., localStorage)

  whitelist: ['product', 'cart'], // <<-- Array of slice names you want to persist

  // blacklist: ['someOtherSlice'] // Optional: Array of slice names you do NOT want to persist

};

// Create a persisted reducer by wrapping your root reducer

// This adds persistence capabilities to your combined reducers

const persistedReducer = persistReducer(persistConfig, rootReducer);

// Configure the Redux store

export const store = configureStore({

  reducer: persistedReducer, // Use the persisted reducer

  middleware: (getDefaultMiddleware) =>

    getDefaultMiddleware({

      // Configure middleware to ignore specific actions from redux-persist

      // These actions contain non-serializable data, which is expected for persistence

      serializableCheck: {

        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],

      },

    }),

  // Enable Redux DevTools Extension only in development mode

  devTools: process.env.NODE_ENV !== 'production',

});

// Create a persistor object

// This object is used with PersistGate to trigger rehydration

export const persistor = persistStore(store);

// ============================================================================

// File: src/store/Provider.js

// Description: Client Component to provide the Redux store and handle persistence rehydration.

// ============================================================================

"use client"; // This directive marks this file as a Client Component, necessary for using browser APIs and React hooks

import { Provider } from 'react-redux';

import { PersistGate } from 'redux-persist/integration/react';

// Import the store and persistor created in store.js

import { persistor, store } from './store'; // Adjust the import path if necessary

// ReduxProvider component to wrap your application

export function ReduxProvider({ children }) {

  return (

    // Provide the Redux store to the application

    <Provider store={store}>

      {/* PersistGate delays rendering of children until the persisted state is loaded and rehydrated.

          The `loading` prop can be used to show a loading indicator while rehydrating.

          `loading={null}` means render children immediately even if state is not fully rehydrated yet. */}

      <PersistGate loading={null} persistor={persistor}>

        {children} {/* Your application components go here */}

      </PersistGate>

    </Provider>

  );

}

// ============================================================================

// File: src/store/index.js (Optional Barrel File)

// Description: Exports key items from the store directory for cleaner imports elsewhere.

// ============================================================================

// Import the store and persistor


// Import the ReduxProvider component

import { ReduxProvider } from './Provider';

// If you created a separate hooks.js file for typed hooks (recommended for TypeScript),

// you would import and export them here as well, e.g.:

// export * from './hooks';

// Export the main store, persistor, and Provider

export { persistor, ReduxProvider, store };

// ============================================================================

// File: src/app/layout.js (Modification)

// Description: Integrate the ReduxProvider into your root layout to make the store available globally.

// ============================================================================

// Assuming you have other imports like fonts and global CSS

  import { Inter } from 'next/font/google';

import './globals.css'; // Or your main CSS file

// Import the ReduxProvider component

// Adjust the import path based on your structure and aliases (e.g., '../store' or '@/store')


const inter = Inter({ subsets: ['latin'] });

export const metadata = {

  title: 'My Next.js JS App with Redux Persistent Store',

  description: 'Using Redux Toolkit and Redux Persist in Next.js 15 with JavaScript',

};

// The root layout component

export default function RootLayout({ children }) {

  return (

    <html lang="en">

      {/* Apply font class to the body */}

      <body className={inter.className}>

        {/* Wrap your application content with the ReduxProvider */}

        <ReduxProvider>

          {children} {/* Your page content and nested layouts/components will be rendered here */}

        </ReduxProvider>

      </body>

    </html>

  );

}

// ============================================================================

// File: src/components/CartDisplay.js (Example Usage Component)

// Description: A Client Component demonstrating how to use Redux hooks to interact with the cart state.

// ============================================================================

"use client"; // This component needs to be a Client Component because it uses React hooks and interacts with client-side Redux state

import { useDispatch, useSelector } from 'react-redux';

// Import action creators from the cart slice

import { removeItem, updateItemQuantity } from '../store/slices/cartSlice'; // Adjust import path

// Example component to display and interact with the cart

export default function CartDisplay() {

  // Use useSelector hook to select parts of the state from the Redux store

  const cartItems = useSelector((state) => state.cart.items);

  const totalItems = useSelector((state) => state.cart.totalItems);

  const totalPrice = useSelector((state) => state.cart.totalPrice);

  // Use useDispatch hook to get the dispatch function, used to dispatch actions

  const dispatch = useDispatch();

  return (

    <div>

      <h2>Shopping Cart</h2>

      <p>Total Items: {totalItems}</p>

      <p>Total Price: ${totalPrice.toFixed(2)}</p>

      <ul>

        {/* Map through cart items and display them */}

        {cartItems.map(item => (

          <li key={item.id}>

            {item.name} - ${item.price.toFixed(2)} x {item.quantity}

            {/* Buttons to update item quantity or remove item */}

            <button onClick={() => dispatch(updateItemQuantity({ id: item.id, quantity: item.quantity - 1 }))}>-</button>

            <button onClick={() => dispatch(updateItemQuantity({ id: item.id, quantity: item.quantity + 1 }))}>+</button>

            <button onClick={() => dispatch(removeItem(item.id))}>Remove</button>

          </li>

        ))}

      </ul>

    </div>

  );

}

